package api

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// ExploitInfo contains information about available exploits for a CVE
type ExploitInfo struct {
	CVEID          string         `json:"cve_id"`
	HasExploits    bool           `json:"has_exploits"`
	ExploitDBCount int            `json:"exploitdb_count"`
	GitHubPoCCount int            `json:"github_poc_count"`
	NucleiTemplate bool           `json:"nuclei_template"`
	ExploitDBURLs  []ExploitEntry `json:"exploitdb_urls,omitempty"`
	GitHubPoCs     []GitHubPoC    `json:"github_pocs,omitempty"`
	NucleiURL      string         `json:"nuclei_url,omitempty"`
	LastChecked    time.Time      `json:"last_checked"`
}

// ExploitEntry represents an Exploit-DB entry
type ExploitEntry struct {
	ID          string `json:"id"`
	Title       string `json:"title"`
	URL         string `json:"url"`
	Type        string `json:"type,omitempty"`
	Platform    string `json:"platform,omitempty"`
	DatePublish string `json:"date_published,omitempty"`
}

// GitHubPoC represents a GitHub proof-of-concept
type GitHubPoC struct {
	Name        string `json:"name"`
	URL         string `json:"url"`
	Description string `json:"description,omitempty"`
	Stars       int    `json:"stars"`
	UpdatedAt   string `json:"updated_at,omitempty"`
}

// PatchInfo contains information about available patches for a CVE
type PatchInfo struct {
	CVEID       string      `json:"cve_id"`
	HasPatch    bool        `json:"has_patch"`
	References  []Reference `json:"references,omitempty"`
	Advisories  []Advisory  `json:"advisories,omitempty"`
	LastChecked time.Time   `json:"last_checked"`
}

// Reference from NVD
type Reference struct {
	URL    string   `json:"url"`
	Source string   `json:"source,omitempty"`
	Tags   []string `json:"tags,omitempty"`
}

// Advisory represents a vendor security advisory
type Advisory struct {
	Vendor string `json:"vendor"`
	URL    string `json:"url"`
	Title  string `json:"title,omitempty"`
}

// FetchExploitInfo checks multiple sources for exploit availability
func (c *Client) FetchExploitInfo(cveID string) (*ExploitInfo, error) {
	info := &ExploitInfo{
		CVEID:       cveID,
		LastChecked: time.Now(),
	}

	// Check GitHub for PoCs using GitHub API (no auth required for search)
	pocs, err := c.searchGitHubPoCs(cveID)
	if err == nil && len(pocs) > 0 {
		info.GitHubPoCs = pocs
		info.GitHubPoCCount = len(pocs)
		info.HasExploits = true
	}

	// Check Nuclei templates (projectdiscovery/nuclei-templates)
	nucleiURL := fmt.Sprintf("https://github.com/projectdiscovery/nuclei-templates/blob/main/cves/%s/%s.yaml",
		cveID[4:8], // Year from CVE-YYYY-XXXX
		strings.ToLower(cveID))
	if c.checkURLExists(nucleiURL) {
		info.NucleiTemplate = true
		info.NucleiURL = nucleiURL
		info.HasExploits = true
	}

	// Generate Exploit-DB search URL (we can't scrape but provide the link)
	info.ExploitDBURLs = []ExploitEntry{{
		URL:   fmt.Sprintf("https://www.exploit-db.com/search?cve=%s", cveID),
		Title: "Search Exploit-DB",
	}}

	return info, nil
}

// searchGitHubPoCs searches GitHub for proof-of-concept repositories
func (c *Client) searchGitHubPoCs(cveID string) ([]GitHubPoC, error) {
	// GitHub search API
	searchURL := fmt.Sprintf("https://api.github.com/search/repositories?q=%s+in:name,description,readme&sort=stars&per_page=5",
		url.QueryEscape(cveID))

	req, err := http.NewRequest("GET", searchURL, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/vnd.github.v3+json")
	req.Header.Set("User-Agent", "kevs-tui")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("GitHub API returned status %d", resp.StatusCode)
	}

	var result struct {
		Items []struct {
			Name        string `json:"name"`
			HTMLURL     string `json:"html_url"`
			Description string `json:"description"`
			Stars       int    `json:"stargazers_count"`
			UpdatedAt   string `json:"updated_at"`
		} `json:"items"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	var pocs []GitHubPoC
	for _, item := range result.Items {
		// Filter to only include repos that likely contain the CVE
		nameLower := strings.ToLower(item.Name)
		descLower := strings.ToLower(item.Description)
		cveLower := strings.ToLower(cveID)

		if strings.Contains(nameLower, cveLower) || strings.Contains(descLower, cveLower) {
			pocs = append(pocs, GitHubPoC{
				Name:        item.Name,
				URL:         item.HTMLURL,
				Description: item.Description,
				Stars:       item.Stars,
				UpdatedAt:   item.UpdatedAt,
			})
		}
	}

	return pocs, nil
}

// checkURLExists does a HEAD request to check if a URL exists
func (c *Client) checkURLExists(url string) bool {
	req, err := http.NewRequest("HEAD", url, nil)
	if err != nil {
		return false
	}
	req.Header.Set("User-Agent", "kevs-tui")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return false
	}
	defer resp.Body.Close()

	return resp.StatusCode == http.StatusOK
}

// FetchPatchInfo gets patch/advisory information from NVD references
func (c *Client) FetchPatchInfo(cveID string) (*PatchInfo, error) {
	info := &PatchInfo{
		CVEID:       cveID,
		LastChecked: time.Now(),
	}

	// Fetch from NVD API to get references
	nvdURL := fmt.Sprintf("https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=%s", cveID)

	req, err := http.NewRequest("GET", nvdURL, nil)
	if err != nil {
		return info, err
	}
	req.Header.Set("User-Agent", "kevs-tui")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return info, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return info, fmt.Errorf("NVD API returned status %d", resp.StatusCode)
	}

	var nvdResp struct {
		Vulnerabilities []struct {
			CVE struct {
				References []struct {
					URL    string   `json:"url"`
					Source string   `json:"source"`
					Tags   []string `json:"tags"`
				} `json:"references"`
			} `json:"cve"`
		} `json:"vulnerabilities"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&nvdResp); err != nil {
		return info, err
	}

	if len(nvdResp.Vulnerabilities) == 0 {
		return info, nil
	}

	refs := nvdResp.Vulnerabilities[0].CVE.References

	for _, ref := range refs {
		r := Reference{
			URL:    ref.URL,
			Source: ref.Source,
			Tags:   ref.Tags,
		}
		info.References = append(info.References, r)

		// Check if it's a patch or vendor advisory
		for _, tag := range ref.Tags {
			tagLower := strings.ToLower(tag)
			if tagLower == "patch" || tagLower == "vendor advisory" {
				info.HasPatch = true

				// Try to identify vendor from URL
				vendor := identifyVendor(ref.URL)
				if vendor != "" {
					info.Advisories = append(info.Advisories, Advisory{
						Vendor: vendor,
						URL:    ref.URL,
					})
				}
			}
		}
	}

	return info, nil
}

// identifyVendor attempts to identify the vendor from a URL
func identifyVendor(url string) string {
	urlLower := strings.ToLower(url)

	vendorDomains := map[string]string{
		"microsoft.com":    "Microsoft",
		"apple.com":        "Apple",
		"google.com":       "Google",
		"oracle.com":       "Oracle",
		"adobe.com":        "Adobe",
		"cisco.com":        "Cisco",
		"vmware.com":       "VMware",
		"redhat.com":       "Red Hat",
		"debian.org":       "Debian",
		"ubuntu.com":       "Ubuntu",
		"apache.org":       "Apache",
		"mozilla.org":      "Mozilla",
		"fortinet.com":     "Fortinet",
		"paloaltonetworks": "Palo Alto Networks",
		"juniper.net":      "Juniper",
		"sap.com":          "SAP",
		"atlassian.com":    "Atlassian",
		"jenkins.io":       "Jenkins",
		"wordpress.org":    "WordPress",
		"drupal.org":       "Drupal",
	}

	for domain, vendor := range vendorDomains {
		if strings.Contains(urlLower, domain) {
			return vendor
		}
	}

	return ""
}
