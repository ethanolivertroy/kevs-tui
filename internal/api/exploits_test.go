package api

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"sync/atomic"
	"testing"
	"time"
)

func TestValidateCVEID(t *testing.T) {
	tests := []struct {
		name    string
		cveID   string
		wantErr bool
	}{
		{"valid standard", "CVE-2024-12345", false},
		{"valid short sequence", "CVE-2024-1", false},
		{"valid minimum length", "CVE-2024-1", false},
		{"valid long sequence", "CVE-2024-1234567", false},
		{"too short", "CVE-2024", true},
		{"way too short", "CVE", true},
		{"empty string", "", true},
		{"missing CVE prefix", "XVE-2024-12345", true},
		{"non-numeric year", "CVE-ABCD-12345", true},
		{"lowercase accepted", "cve-2024-12345", false},
		{"mixed case accepted", "Cve-2024-12345", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := ValidateCVEID(tt.cveID)
			if (err != nil) != tt.wantErr {
				t.Errorf("ValidateCVEID(%q) error = %v, wantErr %v", tt.cveID, err, tt.wantErr)
			}
		})
	}
}

func TestIdentifyVendor(t *testing.T) {
	tests := []struct {
		name string
		url  string
		want string
	}{
		{"Microsoft", "https://portal.msrc.microsoft.com/en-US/security-guidance", "Microsoft"},
		{"Apple", "https://support.apple.com/en-us/HT213488", "Apple"},
		{"Google", "https://chromereleases.googleblog.google.com/2024", "Google"},
		{"Red Hat", "https://access.redhat.com/security/cve/CVE-2024-1234", "Red Hat"},
		{"Apache", "https://httpd.apache.org/security/vulnerabilities_24.html", "Apache"},
		{"Cisco", "https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory", "Cisco"},
		{"unknown domain", "https://example.com/advisory/123", ""},
		{"empty URL", "", ""},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := identifyVendor(tt.url)
			if got != tt.want {
				t.Errorf("identifyVendor(%q) = %q, want %q", tt.url, got, tt.want)
			}
		})
	}
}

func TestFetchExploitInfo(t *testing.T) {
	t.Run("invalid CVE returns error", func(t *testing.T) {
		resetAllCaches()
		handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			t.Error("should not make HTTP request for invalid CVE")
		})
		client := setupTestServer(t, handler)

		_, err := client.FetchExploitInfo("bad-id")
		if err == nil {
			t.Fatal("expected error for invalid CVE ID")
		}
	})

	t.Run("GitHub PoCs found", func(t *testing.T) {
		resetAllCaches()
		handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if strings.Contains(r.URL.Path, "/search/repositories") {
				result := map[string]interface{}{
					"items": []map[string]interface{}{
						{
							"name":             "CVE-2024-1234-poc",
							"html_url":         "https://github.com/user/CVE-2024-1234-poc",
							"description":      "Proof of concept for CVE-2024-1234",
							"stargazers_count": 42,
							"updated_at":       "2024-06-01T00:00:00Z",
						},
						{
							"name":             "unrelated-repo",
							"html_url":         "https://github.com/user/unrelated-repo",
							"description":      "Does not mention the CVE",
							"stargazers_count": 100,
							"updated_at":       "2024-06-01T00:00:00Z",
						},
					},
				}
				w.Header().Set("Content-Type", "application/json")
				json.NewEncoder(w).Encode(result)
				return
			}
			// HEAD request for Nuclei template — 404
			w.WriteHeader(http.StatusNotFound)
		})
		client := setupTestServer(t, handler)

		info, err := client.FetchExploitInfo("CVE-2024-1234")
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if !info.HasExploits {
			t.Error("HasExploits = false, want true")
		}
		if info.GitHubPoCCount != 1 {
			t.Errorf("GitHubPoCCount = %d, want 1 (unrelated repo filtered)", info.GitHubPoCCount)
		}
		if len(info.GitHubPoCs) != 1 {
			t.Fatalf("got %d PoCs, want 1", len(info.GitHubPoCs))
		}
		if info.GitHubPoCs[0].Stars != 42 {
			t.Errorf("Stars = %d, want 42", info.GitHubPoCs[0].Stars)
		}
	})

	t.Run("Nuclei template exists", func(t *testing.T) {
		resetAllCaches()
		handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if strings.Contains(r.URL.Path, "/search/repositories") {
				// No GitHub PoCs
				w.Header().Set("Content-Type", "application/json")
				fmt.Fprint(w, `{"items":[]}`)
				return
			}
			// HEAD request for Nuclei template — 200 OK
			if r.Method == http.MethodHead {
				w.WriteHeader(http.StatusOK)
				return
			}
			w.WriteHeader(http.StatusNotFound)
		})
		client := setupTestServer(t, handler)

		info, err := client.FetchExploitInfo("CVE-2024-5678")
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if !info.NucleiTemplate {
			t.Error("NucleiTemplate = false, want true")
		}
		if info.NucleiURL == "" {
			t.Error("NucleiURL is empty")
		}
	})

	t.Run("Nuclei template 404", func(t *testing.T) {
		resetAllCaches()
		handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if strings.Contains(r.URL.Path, "/search/repositories") {
				w.Header().Set("Content-Type", "application/json")
				fmt.Fprint(w, `{"items":[]}`)
				return
			}
			w.WriteHeader(http.StatusNotFound)
		})
		client := setupTestServer(t, handler)

		info, err := client.FetchExploitInfo("CVE-2024-9999")
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if info.NucleiTemplate {
			t.Error("NucleiTemplate = true, want false for 404")
		}
	})

	t.Run("ExploitDB URL always present", func(t *testing.T) {
		resetAllCaches()
		handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if strings.Contains(r.URL.Path, "/search/repositories") {
				w.Header().Set("Content-Type", "application/json")
				fmt.Fprint(w, `{"items":[]}`)
				return
			}
			w.WriteHeader(http.StatusNotFound)
		})
		client := setupTestServer(t, handler)

		info, err := client.FetchExploitInfo("CVE-2024-1111")
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if len(info.ExploitDBURLs) == 0 {
			t.Fatal("ExploitDBURLs is empty, want at least search link")
		}
		if !strings.Contains(info.ExploitDBURLs[0].URL, "exploit-db.com") {
			t.Errorf("ExploitDB URL = %q, want exploit-db.com URL", info.ExploitDBURLs[0].URL)
		}
	})

	t.Run("cache hit", func(t *testing.T) {
		resetAllCaches()
		var requestCount atomic.Int32

		handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			requestCount.Add(1)
			if strings.Contains(r.URL.Path, "/search/repositories") {
				w.Header().Set("Content-Type", "application/json")
				fmt.Fprint(w, `{"items":[]}`)
				return
			}
			w.WriteHeader(http.StatusNotFound)
		})
		client := setupTestServer(t, handler)

		_, err := client.FetchExploitInfo("CVE-2024-2222")
		if err != nil {
			t.Fatalf("first call: %v", err)
		}
		first := requestCount.Load()

		_, err = client.FetchExploitInfo("CVE-2024-2222")
		if err != nil {
			t.Fatalf("second call: %v", err)
		}

		if got := requestCount.Load(); got != first {
			t.Errorf("made %d total requests, want %d (second call should be cached)", got, first)
		}
	})

	t.Run("cache expiry", func(t *testing.T) {
		resetAllCaches()
		var requestCount atomic.Int32

		handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			requestCount.Add(1)
			if strings.Contains(r.URL.Path, "/search/repositories") {
				w.Header().Set("Content-Type", "application/json")
				fmt.Fprint(w, `{"items":[]}`)
				return
			}
			w.WriteHeader(http.StatusNotFound)
		})
		client := setupTestServer(t, handler)

		_, err := client.FetchExploitInfo("CVE-2024-3333")
		if err != nil {
			t.Fatalf("first call: %v", err)
		}
		first := requestCount.Load()

		// Expire cache
		exploitCacheMu.Lock()
		if entry, ok := exploitCacheEntries["CVE-2024-3333"]; ok {
			entry.fetchedAt = time.Now().Add(-2 * exploitCacheTTL)
			exploitCacheEntries["CVE-2024-3333"] = entry
		}
		exploitCacheMu.Unlock()

		_, err = client.FetchExploitInfo("CVE-2024-3333")
		if err != nil {
			t.Fatalf("second call: %v", err)
		}

		if got := requestCount.Load(); got <= first {
			t.Errorf("after cache expiry, got %d total requests, want > %d", got, first)
		}
	})

	t.Run("GitHub API error is graceful", func(t *testing.T) {
		resetAllCaches()
		handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if strings.Contains(r.URL.Path, "/search/repositories") {
				w.WriteHeader(http.StatusForbidden) // rate limited
				return
			}
			w.WriteHeader(http.StatusNotFound)
		})
		client := setupTestServer(t, handler)

		info, err := client.FetchExploitInfo("CVE-2024-4444")
		if err != nil {
			t.Fatalf("expected graceful degradation, got error: %v", err)
		}
		// Should still return info (with ExploitDB link at minimum)
		if info == nil {
			t.Fatal("info is nil")
		}
		if info.GitHubPoCCount != 0 {
			t.Errorf("GitHubPoCCount = %d, want 0 after API error", info.GitHubPoCCount)
		}
	})
}

func TestFetchPatchInfo(t *testing.T) {
	t.Run("invalid CVE returns error", func(t *testing.T) {
		resetAllCaches()
		handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			t.Error("should not make HTTP request for invalid CVE")
		})
		client := setupTestServer(t, handler)

		_, err := client.FetchPatchInfo("not-a-cve")
		if err == nil {
			t.Fatal("expected error for invalid CVE ID")
		}
	})

	t.Run("patch tag detected", func(t *testing.T) {
		resetAllCaches()
		handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			resp := map[string]interface{}{
				"vulnerabilities": []map[string]interface{}{
					{
						"cve": map[string]interface{}{
							"references": []map[string]interface{}{
								{
									"url":    "https://portal.msrc.microsoft.com/advisory/CVE-2024-1234",
									"source": "nvd@nist.gov",
									"tags":   []string{"Patch"},
								},
								{
									"url":    "https://example.com/info",
									"source": "nvd@nist.gov",
									"tags":   []string{"Third Party Advisory"},
								},
							},
						},
					},
				},
			}
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(resp)
		})
		client := setupTestServer(t, handler)

		info, err := client.FetchPatchInfo("CVE-2024-1234")
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if !info.HasPatch {
			t.Error("HasPatch = false, want true")
		}
		if len(info.Advisories) != 1 {
			t.Fatalf("got %d advisories, want 1", len(info.Advisories))
		}
		if info.Advisories[0].Vendor != "Microsoft" {
			t.Errorf("Vendor = %q, want Microsoft", info.Advisories[0].Vendor)
		}
		if len(info.References) != 2 {
			t.Errorf("got %d references, want 2", len(info.References))
		}
	})

	t.Run("vendor advisory tag", func(t *testing.T) {
		resetAllCaches()
		handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			resp := map[string]interface{}{
				"vulnerabilities": []map[string]interface{}{
					{
						"cve": map[string]interface{}{
							"references": []map[string]interface{}{
								{
									"url":    "https://access.redhat.com/security/cve/CVE-2024-5678",
									"source": "nvd@nist.gov",
									"tags":   []string{"Vendor Advisory"},
								},
							},
						},
					},
				},
			}
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(resp)
		})
		client := setupTestServer(t, handler)

		info, err := client.FetchPatchInfo("CVE-2024-5678")
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if !info.HasPatch {
			t.Error("HasPatch = false, want true for 'Vendor Advisory' tag")
		}
		if len(info.Advisories) != 1 {
			t.Fatalf("got %d advisories, want 1", len(info.Advisories))
		}
		if info.Advisories[0].Vendor != "Red Hat" {
			t.Errorf("Vendor = %q, want Red Hat", info.Advisories[0].Vendor)
		}
	})

	t.Run("no patch tags", func(t *testing.T) {
		resetAllCaches()
		handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			resp := map[string]interface{}{
				"vulnerabilities": []map[string]interface{}{
					{
						"cve": map[string]interface{}{
							"references": []map[string]interface{}{
								{
									"url":    "https://example.com/info",
									"source": "nvd@nist.gov",
									"tags":   []string{"Third Party Advisory"},
								},
							},
						},
					},
				},
			}
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(resp)
		})
		client := setupTestServer(t, handler)

		info, err := client.FetchPatchInfo("CVE-2024-8888")
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if info.HasPatch {
			t.Error("HasPatch = true, want false when no patch/advisory tags")
		}
		if len(info.Advisories) != 0 {
			t.Errorf("got %d advisories, want 0", len(info.Advisories))
		}
	})

	t.Run("multiple vendors", func(t *testing.T) {
		resetAllCaches()
		handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			resp := map[string]interface{}{
				"vulnerabilities": []map[string]interface{}{
					{
						"cve": map[string]interface{}{
							"references": []map[string]interface{}{
								{
									"url":    "https://portal.msrc.microsoft.com/advisory",
									"source": "nvd@nist.gov",
									"tags":   []string{"Patch"},
								},
								{
									"url":    "https://access.redhat.com/errata",
									"source": "nvd@nist.gov",
									"tags":   []string{"Patch"},
								},
								{
									"url":    "https://www.debian.org/security/dsa",
									"source": "nvd@nist.gov",
									"tags":   []string{"Vendor Advisory"},
								},
							},
						},
					},
				},
			}
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(resp)
		})
		client := setupTestServer(t, handler)

		info, err := client.FetchPatchInfo("CVE-2024-7777")
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if !info.HasPatch {
			t.Error("HasPatch = false, want true")
		}
		if len(info.Advisories) != 3 {
			t.Errorf("got %d advisories, want 3", len(info.Advisories))
		}

		vendors := make(map[string]bool)
		for _, adv := range info.Advisories {
			vendors[adv.Vendor] = true
		}
		for _, want := range []string{"Microsoft", "Red Hat", "Debian"} {
			if !vendors[want] {
				t.Errorf("missing vendor %q in advisories", want)
			}
		}
	})

	t.Run("cache hit", func(t *testing.T) {
		resetAllCaches()
		var requestCount atomic.Int32

		handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			requestCount.Add(1)
			resp := map[string]interface{}{
				"vulnerabilities": []map[string]interface{}{
					{"cve": map[string]interface{}{"references": []interface{}{}}},
				},
			}
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(resp)
		})
		client := setupTestServer(t, handler)

		_, err := client.FetchPatchInfo("CVE-2024-1111")
		if err != nil {
			t.Fatalf("first call: %v", err)
		}
		first := requestCount.Load()

		_, err = client.FetchPatchInfo("CVE-2024-1111")
		if err != nil {
			t.Fatalf("second call: %v", err)
		}

		if got := requestCount.Load(); got != first {
			t.Errorf("made %d total requests, want %d (second should be cached)", got, first)
		}
	})

	t.Run("non-200 returns partial info", func(t *testing.T) {
		resetAllCaches()
		handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.WriteHeader(http.StatusServiceUnavailable)
		})
		client := setupTestServer(t, handler)

		info, err := client.FetchPatchInfo("CVE-2024-2222")
		// FetchPatchInfo returns partial info + error for non-200
		if err == nil {
			t.Error("expected error for non-200 status")
		}
		if info == nil {
			t.Fatal("expected partial info even on error")
		}
		if info.CVEID != "CVE-2024-2222" {
			t.Errorf("CVEID = %q, want CVE-2024-2222", info.CVEID)
		}
	})

	t.Run("input normalization lowercase", func(t *testing.T) {
		resetAllCaches()
		handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			resp := map[string]interface{}{
				"vulnerabilities": []map[string]interface{}{
					{"cve": map[string]interface{}{"references": []interface{}{}}},
				},
			}
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(resp)
		})
		client := setupTestServer(t, handler)

		// Note: FetchPatchInfo validates before trimming, so whitespace
		// would fail validation. Only test case normalization here.
		info, err := client.FetchPatchInfo("cve-2024-3333")
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if info.CVEID != "CVE-2024-3333" {
			t.Errorf("CVEID = %q, want CVE-2024-3333 (normalized)", info.CVEID)
		}
	})
}
