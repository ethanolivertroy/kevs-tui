package model

import (
	"testing"
	"time"
)

func TestNVDURL(t *testing.T) {
	tests := []struct {
		name     string
		cveID    string
		expected string
	}{
		{"standard CVE", "CVE-2024-1234", "https://nvd.nist.gov/vuln/detail/CVE-2024-1234"},
		{"older CVE", "CVE-2021-44228", "https://nvd.nist.gov/vuln/detail/CVE-2021-44228"},
		{"empty CVE", "", "https://nvd.nist.gov/vuln/detail/"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			v := Vulnerability{CVEID: tt.cveID}
			if got := v.NVDURL(); got != tt.expected {
				t.Errorf("NVDURL() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestIsOverdue(t *testing.T) {
	now := time.Now()

	tests := []struct {
		name     string
		dueDate  time.Time
		expected bool
	}{
		{"zero date", time.Time{}, false},
		{"yesterday (overdue)", now.AddDate(0, 0, -1), true},
		{"week ago (overdue)", now.AddDate(0, 0, -7), true},
		{"tomorrow (not overdue)", now.AddDate(0, 0, 1), false},
		{"next week (not overdue)", now.AddDate(0, 0, 7), false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			v := Vulnerability{DueDate: tt.dueDate}
			if got := v.IsOverdue(); got != tt.expected {
				t.Errorf("IsOverdue() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestDaysUntilDue(t *testing.T) {
	now := time.Now()

	tests := []struct {
		name        string
		dueDate     time.Time
		expectRange [2]int // [min, max] to handle time edge cases
	}{
		{"zero date", time.Time{}, [2]int{0, 0}},
		{"7 days ago", now.AddDate(0, 0, -7), [2]int{-8, -6}},
		{"yesterday", now.AddDate(0, 0, -1), [2]int{-2, -1}},
		{"tomorrow", now.AddDate(0, 0, 1), [2]int{0, 1}},
		{"week from now", now.AddDate(0, 0, 7), [2]int{6, 7}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			v := Vulnerability{DueDate: tt.dueDate}
			got := v.DaysUntilDue()
			if got < tt.expectRange[0] || got > tt.expectRange[1] {
				t.Errorf("DaysUntilDue() = %v, want in range [%d, %d]", got, tt.expectRange[0], tt.expectRange[1])
			}
		})
	}
}

func TestDueDateStatus(t *testing.T) {
	now := time.Now()

	tests := []struct {
		name     string
		dueDate  time.Time
		contains string // Check if output contains this substring
	}{
		{"zero date", time.Time{}, "No due date"},
		{"overdue", now.AddDate(0, 0, -5), "OVERDUE"},
		{"future", now.AddDate(0, 0, 10), "days left"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			v := Vulnerability{DueDate: tt.dueDate}
			got := v.DueDateStatus()
			if tt.contains != "" && !containsString(got, tt.contains) {
				t.Errorf("DueDateStatus() = %q, want to contain %q", got, tt.contains)
			}
		})
	}
}

func TestEPSSPercent(t *testing.T) {
	tests := []struct {
		name     string
		score    float64
		expected string
	}{
		{"zero score", 0, ""},
		{"low score", 0.01, "1.0%"},
		{"medium score", 0.5, "50.0%"},
		{"high score", 0.95, "95.0%"},
		{"max score", 1.0, "100.0%"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			v := Vulnerability{EPSS: EPSSScore{Score: tt.score}}
			if got := v.EPSSPercent(); got != tt.expected {
				t.Errorf("EPSSPercent() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func TestEPSSPercentileStr(t *testing.T) {
	tests := []struct {
		name       string
		percentile float64
		contains   string
	}{
		{"zero percentile", 0, ""},
		{"low percentile", 0.5, "percentile"},
		{"high percentile (95th)", 0.95, "Top"},
		{"very high percentile (99th)", 0.99, "Top"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			v := Vulnerability{EPSS: EPSSScore{Percentile: tt.percentile}}
			got := v.EPSSPercentileStr()
			if tt.contains == "" && got != "" {
				t.Errorf("EPSSPercentileStr() = %q, want empty string", got)
			} else if tt.contains != "" && !containsString(got, tt.contains) {
				t.Errorf("EPSSPercentileStr() = %q, want to contain %q", got, tt.contains)
			}
		})
	}
}

// Helper function
func containsString(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(substr) == 0 ||
		(len(s) > 0 && len(substr) > 0 && findSubstring(s, substr)))
}

func findSubstring(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
